name: Laravel CI with Docker

# Triggers the workflow on push or pull request events but only for the main branch
# Also allows manual triggering from the Actions tab
on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']
  workflow_dispatch:

jobs:
  laravel-ci:
    runs-on: ubuntu-latest

    steps:
    # 1. Checkout the code from the repository
    - name: Checkout code
      uses: actions/checkout@v4

    # 2. Copy the .env file for the CI environment
    - name: Setup Laravel environment file
      run: cp .env.example .env

    # 3. Build and start the Docker containers in the background
    - name: Build and run Docker containers
      run: docker-compose -f ./dev-docker/docker-compose.yml up --build -d

    # 4. Display Docker status to confirm containers are running
    - name: Check Docker container status
      run: docker-compose -f ./dev-docker/docker-compose.yml ps

    # 5. Install Composer dependencies inside the 'app' container
    - name: Install Composer Dependencies
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app composer install --no-interaction --no-progress

    # 6. Generate application key
    - name: Generate App Key
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app php artisan key:generate

    # 7. Run database migrations
    - name: Run Database Migrations
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app php artisan migrate --force

    # 8. Run Code Style Check (Pint)
    - name: Run Code Style Check with Pint
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app vendor/bin/pint --test

    # 9. Run Static Analysis (PHPStan)
    - name: Run Static Analysis with PHPStan
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app vendor/bin/phpstan analyse --memory-limit=1G

    # 10. Run Tests (PHPUnit)
    - name: Run Tests with PHPUnit
      run: docker-compose -f ./dev-docker/docker-compose.yml exec -T app vendor/bin/phpunit
