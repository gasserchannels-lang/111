--- /dev/null
+++ b/tests/Unit/Repositories/ProductRepositoryTest.php
@@ -0,0 +1,300 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Tests\Unit\Repositories;
+
+use App\Models\Product;
+use App\Models\Category;
+use App\Models\Brand;
+use App\Repositories\ProductRepository;
+use App\Exceptions\ProductUpdateException;
+use Illuminate\Database\Eloquent\Collection;
+use Illuminate\Pagination\LengthAwarePaginator;
+use Illuminate\Foundation\Testing\RefreshDatabase;
+use Illuminate\Support\Facades\Cache;
+use Illuminate\Support\Facades\DB;
+use Illuminate\Support\Facades\Log;
+use Illuminate\Validation\ValidationException;
+use Tests\TestCase;
+use Mockery;
+
+class ProductRepositoryTest extends TestCase
+{
+    use RefreshDatabase;
+
+    private ProductRepository $repository;
+
+    protected function setUp(): void
+    {
+        parent::setUp();
+        $this->repository = new ProductRepository();
+    }
+
+    protected function tearDown(): void
+    {
+        Cache::flush();
+        parent::tearDown();
+    }
+
+    public function test_get_paginated_active_returns_paginated_products(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        Product::factory()->count(5)->create([
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+        Product::factory()->count(3)->create([
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => false,
+        ]);
+
+        // Act
+        $result = $this->repository->getPaginatedActive(10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $this->assertEquals(5, $result->total());
+        $this->assertEquals(10, $result->perPage());
+        $this->assertTrue($result->every(fn($product) => $product->is_active));
+    }
+
+    public function test_find_by_slug_returns_product_when_found(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        $product = Product::factory()->create([
+            'slug' => 'test-product',
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->findBySlug('test-product');
+
+        // Assert
+        $this->assertInstanceOf(Product::class, $result);
+        $this->assertEquals($product->id, $result->id);
+        $this->assertEquals('test-product', $result->slug);
+        $this->assertTrue($result->is_active);
+    }
+
+    public function test_find_by_slug_returns_null_when_not_found(): void
+    {
+        // Act
+        $result = $this->repository->findBySlug('non-existent-product');
+
+        // Assert
+        $this->assertNull($result);
+    }
+
+    public function test_find_by_slug_throws_exception_for_invalid_slug_format(): void
+    {
+        // Act & Assert
+        $this->expectException(\InvalidArgumentException::class);
+        $this->expectExceptionMessage('Invalid slug format');
+        $this->repository->findBySlug('invalid slug format!');
+    }
+
+    public function test_find_by_slug_returns_null_for_inactive_product(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        Product::factory()->create([
+            'slug' => 'inactive-product',
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => false,
+        ]);
+
+        // Act
+        $result = $this->repository->findBySlug('inactive-product');
+
+        // Assert
+        $this->assertNull($result);
+    }
+
+    public function test_get_related_returns_products_from_same_category(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        $product = Product::factory()->create([
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+        Product::factory()->count(3)->create([
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->getRelated($product, 2);
+
+        // Assert
+        $this->assertInstanceOf(Collection::class, $result);
+        $this->assertLessThanOrEqual(2, $result->count());
+        $this->assertTrue($result->every(fn($relatedProduct) =>
+            $relatedProduct->category_id === $category->id &&
+            $relatedProduct->id !== $product->id
+        ));
+    }
+
+    public function test_get_related_throws_exception_for_invalid_limit(): void
+    {
+        // Arrange
+        $product = Product::factory()->create();
+
+        // Act & Assert
+        $this->expectException(\InvalidArgumentException::class);
+        $this->expectExceptionMessage('Limit must be between 1 and 20');
+        $this->repository->getRelated($product, 0);
+    }
+
+    public function test_get_related_throws_exception_for_limit_too_high(): void
+    {
+        // Arrange
+        $product = Product::factory()->create();
+
+        // Act & Assert
+        $this->expectException(\InvalidArgumentException::class);
+        $this->expectExceptionMessage('Limit must be between 1 and 20');
+        $this->repository->getRelated($product, 25);
+    }
+
+    public function test_search_returns_paginated_results(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        Product::factory()->create([
+            'name' => 'Test Product',
+            'description' => 'Test description',
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->search('Test', [], 10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $this->assertGreaterThan(0, $result->total());
+    }
+
+    public function test_search_applies_category_filter(): void
+    {
+        // Arrange
+        $category1 = Category::factory()->create();
+        $category2 = Category::factory()->create();
+        $brand = Brand::factory()->create();
+
+        Product::factory()->create([
+            'name' => 'Product 1',
+            'category_id' => $category1->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+        Product::factory()->create([
+            'name' => 'Product 2',
+            'category_id' => $category2->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->search('Product', ['category_id' => $category1->id], 10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $this->assertEquals(1, $result->total());
+        $this->assertTrue($result->every(fn($product) => $product->category_id === $category1->id));
+    }
+
+    public function test_search_applies_price_filters(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+
+        Product::factory()->create([
+            'name' => 'Cheap Product',
+            'price' => 50.00,
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+        Product::factory()->create([
+            'name' => 'Expensive Product',
+            'price' => 200.00,
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->search('Product', [
+            'min_price' => 100.00,
+            'max_price' => 300.00
+        ], 10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $this->assertEquals(1, $result->total());
+        $this->assertTrue($result->every(fn($product) =>
+            $product->price >= 100.00 && $product->price <= 300.00
+        ));
+    }
+
+    public function test_search_throws_validation_exception_for_invalid_filters(): void
+    {
+        // Act & Assert
+        $this->expectException(ValidationException::class);
+        $this->repository->search('Test', ['category_id' => 'invalid'], 10);
+    }
+
+    public function test_search_throws_validation_exception_for_invalid_price_range(): void
+    {
+        // Act & Assert
+        $this->expectException(ValidationException::class);
+        $this->repository->search('Test', [
+            'min_price' => 100.00,
+            'max_price' => 50.00
+        ], 10);
+    }
+
+    public function test_update_price_returns_true_when_successful(): void
+    {
+        // Arrange
+        $product = Product::factory()->create(['price' => 100.00]);
+        $newPrice = 150.00;
+
+        // Act
+        $result = $this->repository->updatePrice($product, $newPrice);
+
+        // Assert
+        $this->assertTrue($result);
+        $this->assertDatabaseHas('products', [
+            'id' => $product->id,
+            'price' => $newPrice,
+        ]);
+    }
+
+    public function test_update_price_throws_validation_exception_for_invalid_price(): void
+    {
+        // Arrange
+        $product = Product::factory()->create();
+
+        // Act & Assert
+        $this->expectException(ValidationException::class);
+        $this->repository->updatePrice($product, -10.00);
+    }
+
+    public function test_update_price_throws_validation_exception_for_non_numeric_price(): void
+    {
+        // Arrange
+        $product = Product::factory()->create();
+
+        // Act & Assert
+        $this->expectException(ValidationException::class);
+        $this->repository->updatePrice($product, 'invalid');
+    }
+
+    public function test_update_price_rounds_price_to_two_decimal_places(): void
+    {
+        // Arrange
+        $product = Product::factory()->create(['price' => 100.00]);
+        $newPrice = 150.123456;
+        $expectedPrice = 150.12;
+
+        // Act
+        $result = $this->repository->updatePrice($product, $newPrice);
+
+        // Assert
+        $this->assertTrue($result);
+        $this->assertDatabaseHas('products', [
+            'id' => $product->id,
+            'price' => $expectedPrice,
+        ]);
+    }
+
+    public function test_update_price_handles_concurrent_updates(): void
+    {
+        // Arrange
+        $product = Product::factory()->create(['price' => 100.00]);
+        $newPrice = 150.00;
+
+        // Mock DB transaction to simulate concurrent update
+        DB::shouldReceive('transaction')
+            ->once()
+            ->andReturnUsing(function ($callback) {
+                return $callback();
+            });
+
+        // Act
+        $result = $this->repository->updatePrice($product, $newPrice);
+
+        // Assert
+        $this->assertTrue($result);
+    }
+
+    public function test_search_applies_sorting(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+
+        Product::factory()->create([
+            'name' => 'Apple Product',
+            'price' => 200.00,
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+        Product::factory()->create([
+            'name' => 'Banana Product',
+            'price' => 100.00,
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act - Test name ascending sort
+        $result = $this->repository->search('Product', ['sort_by' => 'name_asc'], 10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $products = $result->items();
+        $this->assertEquals('Apple Product', $products[0]->name);
+        $this->assertEquals('Banana Product', $products[1]->name);
+    }
+
+    public function test_search_handles_empty_query(): void
+    {
+        // Arrange
+        $category = Category::factory()->create();
+        $brand = Brand::factory()->create();
+        Product::factory()->count(3)->create([
+            'category_id' => $category->id,
+            'brand_id' => $brand->id,
+            'is_active' => true,
+        ]);
+
+        // Act
+        $result = $this->repository->search('', [], 10);
+
+        // Assert
+        $this->assertInstanceOf(LengthAwarePaginator::class, $result);
+        $this->assertEquals(3, $result->total());
+    }
+}
