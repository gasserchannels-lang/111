<?php

declare(strict_types=1);

namespace App\Services;

use Exception;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

final class VulnerabilityScanService
{
    /**
     * @var array<string, mixed>
     */
    private array $config;

    public function __construct()
    {
        $config = config('vulnerability_scan', [
            'enabled' => true,
            'scan_frequency' => 'daily', // daily, weekly, monthly
            'notify_on_critical' => true,
            'notify_on_high' => true,
            'exclude_paths' => ['vendor/', 'node_modules/', '.git/'],
            'max_scan_time' => 300, // 5 minutes
        ]);
        $this->config = is_array($config) ? $config : [];
    }

    /**
     * Run vulnerability scan.
     *
     * @return array<string, mixed>
     */
    public function runScan(): array
    {
        if (! $this->config['enabled']) {
            return ['status' => 'disabled', 'message' => 'Vulnerability scanning is disabled'];
        }

        $startTime = microtime(true);
        $results = [
            'scan_id' => uniqid('scan_'),
            'started_at' => now()->toISOString(),
            'vulnerabilities' => [],
            'summary' => [
                'total' => 0,
                'critical' => 0,
                'high' => 0,
                'medium' => 0,
                'low' => 0,
            ],
        ];

        try {
            // Scan dependencies
            $results['vulnerabilities']['dependencies'] = $this->scanDependencies();

            // Scan code
            $results['vulnerabilities']['code'] = $this->scanCode();

            // Scan configuration
            $results['vulnerabilities']['config'] = $this->scanConfiguration();

            // Calculate summary
            $results['summary'] = $this->calculateSummary($results['vulnerabilities']);

            $results['completed_at'] = now()->toISOString();
            $results['duration'] = microtime(true) - $startTime;
            $results['status'] = 'completed';

            // Cache results
            Cache::put('vulnerability_scan_results', $results, 3600);

            // Send notifications if needed
            $this->sendNotifications($results);

            Log::info('Vulnerability scan completed', $results);
        } catch (Exception $e) {
            $results['status'] = 'failed';
            $results['error'] = $e->getMessage();
            $results['completed_at'] = now()->toISOString();

            Log::error('Vulnerability scan failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }

        return $results;
    }

    /**
     * Scan dependencies for vulnerabilities.
     *
     * @return array<string, mixed>
     */
    private function scanDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Scan Composer dependencies
            $composerVulns = $this->scanComposerDependencies();
            $vulnerabilities = array_merge($vulnerabilities, $composerVulns);

            // Scan NPM dependencies
            $npmVulns = $this->scanNpmDependencies();
            $vulnerabilities = array_merge($vulnerabilities, $npmVulns);
        } catch (Exception $e) {
            Log::error('Dependency scan failed', ['error' => $e->getMessage()]);
        }

        return ['dependencies' => $vulnerabilities];
    }

    /**
     * Scan Composer dependencies.
     *
     * @return list<array<string, mixed>>
     */
    private function scanComposerDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Run composer audit
            $output = shell_exec('composer audit --format=json 2>&1');
            $auditResults = json_decode($output ?: '', true);

            if (is_array($auditResults) && isset($auditResults['advisories']) && is_array($auditResults['advisories'])) {
                foreach ($auditResults['advisories'] as $package => $advisories) {
                    if (is_array($advisories)) {
                        foreach ($advisories as $advisory) {
                            if (is_array($advisory)) {
                                $vulnerabilities[] = [
                                    'type' => 'dependency',
                                    'package' => is_string($package) ? $package : 'unknown',
                                    'severity' => is_string($advisory['severity'] ?? null) ? $advisory['severity'] : 'unknown',
                                    'title' => is_string($advisory['title'] ?? null) ? $advisory['title'] : 'Unknown vulnerability',
                                    'description' => is_string($advisory['description'] ?? null) ? $advisory['description'] : '',
                                    'cve' => $advisory['cve'] ?? null,
                                    'source' => 'composer',
                                ];
                            }
                        }
                    }
                }
            }
        } catch (Exception $e) {
            Log::error('Composer audit failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Scan NPM dependencies.
     *
     * @return list<array<string, mixed>>
     */
    private function scanNpmDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Run npm audit
            $output = shell_exec('npm audit --json 2>&1');
            $auditResults = json_decode($output ?: '', true);

            if (is_array($auditResults) && isset($auditResults['vulnerabilities']) && is_array($auditResults['vulnerabilities'])) {
                foreach ($auditResults['vulnerabilities'] as $package => $vuln) {
                    if (is_array($vuln)) {
                        $vulnerabilities[] = [
                            'type' => 'dependency',
                            'package' => is_string($package) ? $package : 'unknown',
                            'severity' => is_string($vuln['severity'] ?? null) ? $vuln['severity'] : 'unknown',
                            'title' => is_string($vuln['title'] ?? null) ? $vuln['title'] : 'Unknown vulnerability',
                            'description' => is_string($vuln['description'] ?? null) ? $vuln['description'] : '',
                            'cve' => $vuln['cve'] ?? null,
                            'source' => 'npm',
                        ];
                    }
                }
            }
        } catch (Exception $e) {
            Log::error('NPM audit failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Scan code for vulnerabilities.
     *
     * @return array<string, mixed>
     */
    private function scanCode(): array
    {
        $vulnerabilities = [];

        try {
            // Scan for common vulnerabilities
            $vulnerabilities = array_merge($vulnerabilities, $this->scanSqlInjection());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanXss());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanFileUpload());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanAuthentication());
        } catch (Exception $e) {
            Log::error('Code scan failed', ['error' => $e->getMessage()]);
        }

        return ['code' => $vulnerabilities];
    }

    /**
     * Scan for SQL injection vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanSqlInjection(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'DB::raw' => 'Use of DB::raw without proper sanitization',
            'whereRaw' => 'Use of whereRaw without proper sanitization',
            'selectRaw' => 'Use of selectRaw without proper sanitization',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'high',
                    'title' => 'Potential SQL Injection',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for XSS vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanXss(): array
    {
        $vulnerabilities = [];
        $patterns = [
            '{!!' => 'Unescaped output - potential XSS',
            'echo' => 'Direct echo without escaping',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'medium',
                    'title' => 'Potential XSS',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for file upload vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanFileUpload(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'move_uploaded_file' => 'File upload without validation',
            'getClientOriginalName' => 'Using original filename without sanitization',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'high',
                    'title' => 'File Upload Vulnerability',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for authentication vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanAuthentication(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'password' => 'Hardcoded password',
            'secret' => 'Hardcoded secret',
            'api_key' => 'Hardcoded API key',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'critical',
                    'title' => 'Hardcoded Credentials',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan configuration for vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanConfiguration(): array
    {
        $vulnerabilities = [];

        try {
            // Check for debug mode in production
            if (config('app.debug') && config('app.env') === 'production') {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'high',
                    'title' => 'Debug Mode in Production',
                    'description' => 'Debug mode is enabled in production environment',
                    'file' => 'config/app.php',
                ];
            }

            // Check for weak encryption key
            $key = config('app.key');
            if (is_string($key) && strlen($key) < 32) {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'critical',
                    'title' => 'Weak Encryption Key',
                    'description' => 'Application key is too short',
                    'file' => 'config/app.php',
                ];
            }

            // Check for insecure session configuration
            if (config('session.secure') !== true && config('app.env') === 'production') {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'medium',
                    'title' => 'Insecure Session Configuration',
                    'description' => 'Session cookies are not secure',
                    'file' => 'config/session.php',
                ];
            }
        } catch (Exception $e) {
            Log::error('Configuration scan failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Search for patterns in files.
     *
     * @return array<string>
     */
    private function searchInFiles(string $pattern): array
    {
        $files = [];
        $excludePaths = $this->config['exclude_paths'];

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator(base_path(), \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file instanceof \SplFileInfo && $file->isFile() && $file->getExtension() === 'php') {
                $relativePath = str_replace(base_path().'/', '', $file->getPathname());

                // Skip excluded paths
                $shouldExclude = false;
                if (is_array($excludePaths)) {
                    foreach ($excludePaths as $excludePath) {
                        if (is_string($excludePath) && str_starts_with($relativePath, $excludePath)) {
                            $shouldExclude = true;
                            break;
                        }
                    }
                }

                if (! $shouldExclude) {
                    $content = file_get_contents($file->getPathname());
                    if ($content !== false && str_contains($content, $pattern)) {
                        $files[] = $relativePath;
                    }
                }
            }
        }

        return $files;
    }

    /**
     * Calculate vulnerability summary.
     *
     * @param  array<string, mixed>  $vulnerabilities
     * @return array<string, int>
     */
    private function calculateSummary(array $vulnerabilities): array
    {
        $summary = [
            'total' => 0,
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0,
        ];

        foreach ($vulnerabilities as $vulns) {
            if (is_array($vulns)) {
                foreach ($vulns as $vuln) {
                    if (is_array($vuln)) {
                        $summary['total']++;
                        $severity = is_string($vuln['severity'] ?? null) ? strtolower($vuln['severity']) : 'unknown';

                        if (isset($summary[$severity])) {
                            $summary[$severity]++;
                        }
                    }
                }
            }
        }

        return $summary;
    }

    /**
     * Send notifications for vulnerabilities.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendNotifications(array $results): void
    {
        $summary = $results['summary'] ?? [];

        if (is_array($summary) && ($summary['critical'] ?? 0) > 0 && ($this->config['notify_on_critical'] ?? false)) {
            $this->sendCriticalNotification($results);
        }

        if (is_array($summary) && ($summary['high'] ?? 0) > 0 && ($this->config['notify_on_high'] ?? false)) {
            $this->sendHighNotification($results);
        }
    }

    /**
     * Send critical vulnerability notification.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendCriticalNotification(array $results): void
    {
        try {
            $adminEmails = config('app.admin_emails', []);

            if (! empty($adminEmails)) {
                $summary = $results['summary'] ?? [];
                $total = 0;
                $critical = 0;
                $high = 0;
                $medium = 0;
                $low = 0;

                if (is_array($summary)) {
                    $total = is_numeric($summary['total'] ?? null) ? (int) $summary['total'] : 0;
                    $critical = is_numeric($summary['critical'] ?? null) ? (int) $summary['critical'] : 0;
                    $high = is_numeric($summary['high'] ?? null) ? (int) $summary['high'] : 0;
                    $medium = is_numeric($summary['medium'] ?? null) ? (int) $summary['medium'] : 0;
                    $low = is_numeric($summary['low'] ?? null) ? (int) $summary['low'] : 0;
                }

                $scanId = is_string($results['scan_id'] ?? null) ? $results['scan_id'] : 'unknown';
                $completedAt = is_string($results['completed_at'] ?? null) ? $results['completed_at'] : 'unknown';

                \Mail::raw(
                    "Critical vulnerabilities found in COPRRA application:\n\n".
                        "Total vulnerabilities: {$total}\n".
                        "Critical: {$critical}\n".
                        "High: {$high}\n".
                        "Medium: {$medium}\n".
                        "Low: {$low}\n\n".
                        "Scan ID: {$scanId}\n".
                        "Time: {$completedAt}",
                    function ($message) use ($adminEmails): void {
                        $message->to($adminEmails)
                            ->subject('Critical Vulnerabilities Alert - COPRRA');
                    }
                );
            }
        } catch (Exception $e) {
            Log::error('Failed to send critical vulnerability notification', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Send high vulnerability notification.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendHighNotification(array $results): void
    {
        try {
            $adminEmails = config('app.admin_emails', []);

            if (! empty($adminEmails)) {
                $summary = $results['summary'] ?? [];
                $total = 0;
                $critical = 0;
                $high = 0;
                $medium = 0;
                $low = 0;

                if (is_array($summary)) {
                    $total = is_numeric($summary['total'] ?? null) ? (int) $summary['total'] : 0;
                    $critical = is_numeric($summary['critical'] ?? null) ? (int) $summary['critical'] : 0;
                    $high = is_numeric($summary['high'] ?? null) ? (int) $summary['high'] : 0;
                    $medium = is_numeric($summary['medium'] ?? null) ? (int) $summary['medium'] : 0;
                    $low = is_numeric($summary['low'] ?? null) ? (int) $summary['low'] : 0;
                }

                $scanId = is_string($results['scan_id'] ?? null) ? $results['scan_id'] : 'unknown';
                $completedAt = is_string($results['completed_at'] ?? null) ? $results['completed_at'] : 'unknown';

                \Mail::raw(
                    "High severity vulnerabilities found in COPRRA application:\n\n".
                        "Total vulnerabilities: {$total}\n".
                        "Critical: {$critical}\n".
                        "High: {$high}\n".
                        "Medium: {$medium}\n".
                        "Low: {$low}\n\n".
                        "Scan ID: {$scanId}\n".
                        "Time: {$completedAt}",
                    function ($message) use ($adminEmails): void {
                        $message->to($adminEmails)
                            ->subject('High Severity Vulnerabilities Alert - COPRRA');
                    }
                );
            }
        } catch (Exception $e) {
            Log::error('Failed to send high vulnerability notification', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Get last scan results.
     *
     * @return array<string, mixed>|null
     */
    public function getLastScanResults(): ?array
    {
        return Cache::get('vulnerability_scan_results');
    }

    /**
     * Get scan statistics.
     *
     * @return array<string, mixed>
     */
    public function getScanStatistics(): array
    {
        $lastScan = $this->getLastScanResults();

        if (! $lastScan) {
            return [
                'last_scan' => null,
                'total_scans' => 0,
                'average_vulnerabilities' => 0,
            ];
        }

        $summary = $lastScan['summary'] ?? [];
        $averageVulnerabilities = 0;

        if (is_array($summary) && isset($summary['total']) && is_numeric($summary['total'])) {
            $averageVulnerabilities = (int) $summary['total'];
        }

        return [
            'last_scan' => $lastScan['completed_at'] ?? null,
            'total_scans' => 1, // This would be tracked in a database
            'average_vulnerabilities' => $averageVulnerabilities,
            'summary' => $summary,
        ];
    }
}
